# -*- coding: utf-8 -*-
"""EDA OF HOTEL BOOKING ANALYSIS

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RK59OrCXjIr1IAlPHXr0PXVYCd7-SHNF
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline

from google.colab import drive
drive.mount('/content/drive')

path ='/content/drive/MyDrive/DATA FOR PROJECT/'
df = pd.read_csv(path + 'Hotel Bookings.csv')

df.head()

df

df.columns

df.info()

df.shape

"""**(1)- Hotel:** Type of hotel(City or Resort)

**(2)- is_cancelled:** If the booking was cancelled(1) or not(0)

**(3)- lead_time:** Number of days before the actual arrival of the guests

**(4)- arrival_date_year:** Year of arrival date

**(5)- arrival_date_month:** Month of arrival date

**(6)- arrival_date_week_number:** Week number of year for arrival date

**(7)- arrival_date_day_of_month:** Day of arrival date

**(8)- stays_in_weekend_nights:** Number of weekend nights(Saturday or Sunday) spent at the hotel by the guests.

**(9)- stays_in_weel_nights:** Number of weeknights(Monday to Friday) spent at the hotel by the guests.

**(10)- adults:** Number of adults among the guests

**(11)- children:** Number of children

**(12)- babies:** Number of babies

**(13)- meal:** Type of meal booked

**(14)- country:** country of the guests

**(15)-market_segment:** Designation of market segment

**(16)- distribution_channel:** Name of booking distribution channel

**(17)- is_repeated_guest:** If the booking was from a repeated guest(1) or not(0)

**(18)- previous_cancellation:** Number of previous bookings that were cancelled by the customer prior to the current booking

**(19)- previous_bookings_not_cancelled:** Number of previous bookins not cancelled by the customer prior to the current bookin

**(20)- reserved_room_type:** Code from room type reserved

**(21)- assigned_room_type:** Code of room type assigned

**(22)- booking_changes:** Number of changes made to the booking

**(23)- deposit_type:** Type of deposite made by the guest

**(24)- agent:** ID of travel agent who made the booking

**(25)- comapny:** ID of the company that made the booking

**(26)- days_in_waiting_list:** Number of the days the booking was in the waiting list

**(27)- customer_type:** Type of customer, assuming one of four categories

**(28)- adr:** Average daily rate

**(29)- required_car_parking_spaces:** Number of car parking spaces required bt the customer

**(30)- total_of_special_requesrs:** Number of special requests made by the customer

**(31)- reservation_statuse:** Reservation status(Canceled, check-out or no-show)

**(32)- reservation_status_date:** Date at which the last reservation status was updated
"""

Hotel_df = df.copy()

"""Making copy :- It is important to make a copy of the main data frame before any of the proccessing, as it prevents any permanent modification in main data frame in the proccess of EDA."""

Hotel_df.head()

Hotel_df.describe()

Hotel_df.info()

"""###We see that there are 32 columns in the dataframe and some columns like 'children', 'company', 'country' and 'agent' have null values.

First of all we will try to understand the meaning of all columns of the dataframe.

For this we will see the unique values attained by each column whose meaning we are unable to understand.
"""

Hotel_df['hotel'].unique()

Hotel_df['is_canceled'].unique()

Hotel_df['arrival_date_year'].unique()

Hotel_df['meal'].unique()

Hotel_df['market_segment'].unique()

Hotel_df['reserved_room_type'].unique()

Hotel_df['assigned_room_type'].unique()

Hotel_df['distribution_channel'].unique()

Hotel_df['children'].unique()    # This column has 0 as well as null values

"""##Cleaning data

Cleaning data is important step before EDA as it will remove the irrelevant data that can affect the outcome of EDA.

While cleaning data we will perform following steps: \

**(1)-** Remove duplicate rows \
**(2)-** Handling missing values. \
**(3)-** Convert columns to appropriate datatypes. \
**(4)-** Adding important columns

##Step 1: Removing duplicate rows if any
"""

Hotel_df.duplicated()

Hotel_df[Hotel_df.duplicated()]

Hotel_df[Hotel_df.duplicated()].shape   # Show no. of rows of duplicate rows duplicate rows

# Dropping duplicate values
Hotel_df.drop_duplicates(inplace = True)

Hotel_df.shape

"""##Step2: Handling missing values."""

Hotel_df.isnull().sum().sort_values(ascending = False)[:6]

"""Since, company and agent columns have comany number and agent numbers as data. There may be some cases when customer didnt booked hotel via any agent or via any company. So in that case values can be null under these columns.

We will replace null values by 0 in these columns


"""

Hotel_df[['company','agent']] = Hotel_df[['company','agent']].fillna(0)

"""This column 'children' has 0 as value which means 0 children were present in group of customers who made that transaction.
So, 'nan' values are the missing values due to error of recording data.

We will replace the null values under this column with mean value of children.
"""

Hotel_df['children'].fillna(Hotel_df['children'].mean(), inplace = True)

"""Next column with missing value is 'country'. This column represents the country of origin of customer.

Since, this column has datatype of string. We will replace the missing value with the mode of 'country' column.

"""

Hotel_df['country'].fillna('others', inplace = True)

# Checking if all null values are removed
Hotel_df.isnull().sum().sort_values(ascending = False)[:6]

"""There are some rows with total number of adults, children or babies equal to zero. So we will remove such rows."""

Hotel_df[Hotel_df['adults']+Hotel_df['babies']+Hotel_df['children'] == 0].shape

Hotel_df.drop(Hotel_df[Hotel_df['adults']+Hotel_df['babies']+Hotel_df['children'] == 0].index, inplace = True)

"""##Step 3: Converting columns to appropriate datatypes."""

# Converting datatype of columns 'children', 'company' and 'agent' from float to int.
Hotel_df[['children', 'company', 'agent']] = Hotel_df[['children', 'company', 'agent']].astype('int64')

# changing datatype of column 'reservation_status_date' to data_type.
Hotel_df['reservation_status_date'] = pd.to_datetime(Hotel_df['reservation_status_date'], format = '%Y-%m-%d')

"""##Step 4: Adding important columns."""

# Adding total staying days in hotels
Hotel_df['total_stay'] = Hotel_df['stays_in_weekend_nights']+Hotel_df['stays_in_week_nights']

# Adding total people num as column, i.e. total people num = num of adults + children + babies
Hotel_df['total_people'] = Hotel_df['adults']+Hotel_df['children']+Hotel_df['babies']

"""We are adding this column so that we can analyse the stay length at hotels."""

Hotel_df.info()

"""
##**EDA**
Lets first find the correlation between the numerical data.


Since, columns like 'is_cancelled', 'arrival_date_year', 'arrival_date_week_number', 'arrival_date_day_of_month', 'is_repeated_guest', 'company', 'agent' are categorical data having numerical type. So we wont need to check them for correlation.


Also, we have added total_stay and total_people columns. So, we can remove adults, children, babies, stays_in_weekend_nights, stays_in_week_nights columns."""

num_Hotel_df = Hotel_df[['lead_time','previous_cancellations','previous_bookings_not_canceled','booking_changes','days_in_waiting_list','adr','required_car_parking_spaces','total_of_special_requests','total_stay','total_people']]

#correlation matrix
corrmat = num_Hotel_df.corr()
corrmat

f, ax = plt.subplots(figsize=(12, 7))
sns.heatmap(corrmat,annot = True,fmt='.2f', annot_kws={'size': 10}, vmax=.8,  square=True);

"""###1- Total stay length and lead time have slight correlation. This may means that for longer hotel stays people generally plan little before the the actual arrival.

###2- adr is slightly correlated with total_people, which makes sense as more no. of people means more revenue, therefore more adr.

###Lets see does length of stay affects the adr.
"""

plt.figure(figsize = (12,6))
sns.scatterplot(y = 'adr', x = 'total_stay', data = Hotel_df)
plt.show()

"""We notice that there is an outlier in adr, so we will remove that for better scatter plot"""

Hotel_df.drop(Hotel_df[Hotel_df['adr'] > 5000].index, inplace = True)

plt.figure(figsize = (12,6))
sns.scatterplot(y = 'adr', x = 'total_stay', data = Hotel_df)
plt.show()

"""From the scatter plot we can see that as length of tottal_stay increases the adr decreases. This means for longer stay, the better deal for customer can be finalised.

##**Univariate Analysis**

Q1)- Which agent makes most no. of bookings?
"""

Hotel_df['agent'].value_counts().reset_index().rename(columns = {'index':'agent','agent':'num_of_bookings'}).sort_values(by = 'num_of_bookings', ascending = False)

agent_df = pd.DataFrame(Hotel_df['agent'].value_counts()).reset_index().rename(columns = {'index':'agent','agent':'num_of_bookings'}).sort_values(by = 'num_of_bookings', ascending = False)
agent_df.drop(agent_df[agent_df['agent'] == 0].index, inplace = True)            # 0 represents that booking is not made by an agent
agent_df = agent_df[:10]                                                         # Selecting top 10 performing agents
plt.figure(figsize = (10,5))
ax=sns.barplot(x = 'agent', y = 'num_of_bookings', data = agent_df, order = agent_df.sort_values('num_of_bookings' ,ascending = False).agent)
ax.bar_label(ax.containers[0])
plt.title( 'No. of bookings done by agents',fontweight="light", size=20)

"""Agent no. 9 has made most no. of bookings.

Q2) Which room type is in most demand and which room type generates highest adr?
"""

fig, axes = plt.subplots(1, 2, figsize=(18, 8))
sns.countplot(ax = axes[0], x = Hotel_df['assigned_room_type'])
sns.boxplot(ax = axes[1], x = Hotel_df['assigned_room_type'], y = Hotel_df['adr'])
plt.show()

"""Most demanded room type is A, but better adr rooms are of type H, G and C also Hotels should increase the no. of room types A and H to maximise revenue.

Q3) Which meal type is most preffered meal of customers?
"""

plt.figure( figsize=(10, 8))

ax = sns.countplot(x = Hotel_df['meal'])
ax.bar_label(ax.containers[0])
plt.show()

"""Most preferred meal type is BB (Bed and breakfast).

##(1) Hotel wise analysis

Q1) What is percentage of bookings in each hotel?
"""

grouped_by_hotel = Hotel_df.groupby('hotel')
d1 =pd.DataFrame((grouped_by_hotel.size()/Hotel_df.shape[0])*100).reset_index().rename(columns = {0:'Booking %'})      #Calculating percentage
plt.figure(figsize = (8,5))
ax = sns.barplot(x = d1['hotel'], y = d1['Booking %'] )
ax.bar_label(ax.containers[0])
plt.show()

"""Around 60% bookings are for City hotel and 40% bookings are for Resort hotel."""

grouped_by_hotel.size()

d1

pd.DataFrame((grouped_by_hotel.size()/Hotel_df.shape[0])*100).reset_index().rename(columns = {0:'Booking %'})

"""Q2) which hotel seems to make more revenue?"""

Hotel_df.groupby('hotel')['adr'].mean()

d3 = grouped_by_hotel['adr'].mean().reset_index().rename(columns = {'adr':'avg_adr'})   # calculating average adr
plt.figure(figsize = (8,5))
ax = sns.barplot(x = d3['hotel'], y = d3['avg_adr'] )
ax.bar_label(ax.containers[0])
plt.show()

"""Avg adr of Resort hotel is slightly lower than that of City hotel. Hence, City hotel seems to be making slightly more revenue.

Q3) Which hotel has higher lead time?
"""

d2 = grouped_by_hotel['lead_time'].median().reset_index().rename(columns = {'lead_time':'median_lead_time'})
plt.figure(figsize = (8,5))
ax = sns.barplot(x = d2['hotel'], y = d2['median_lead_time'] )
ax.bar_label(ax.containers[0])
plt.show()

"""City hotel has slightly higher median lead time. Also median lead time is significantly higher in each case, this means customers generally plan their hotel visits way to early.

Q4) What is preferred stay length in each hotel?
"""

not_canceled = Hotel_df[Hotel_df['is_canceled'] == 0]
s1 = not_canceled[not_canceled['total_stay'] < 15]
plt.figure(figsize = (10,5))
sns.countplot(x = s1['total_stay'], hue = s1['hotel'])
plt.show()

"""Most common stay length is less than 4 days and generally people prefer City hotel for short stay, but for long stays, Resort Hotel is preferred."""

not_canceled.groupby(['hotel','total_stay'])['total_stay'].count().unstack()

"""Q5) Which hotel has longer waiting time?"""

Hotel_df.groupby(['hotel'])['days_in_waiting_list'].mean().reset_index()

d5 = pd.DataFrame(grouped_by_hotel['days_in_waiting_list'].mean().reset_index().rename(columns = {'days_in_waiting_list':'avg_waiting_period'}))
plt.figure(figsize = (8,5))
sns.barplot(x = d5['hotel'], y = d5['avg_waiting_period'] )
plt.show()

"""City hotel has significantly longer waiting time, hence City Hotel is much busier than Resort Hotel.

Q6) Which hotel has higher bookings cancellation rate.
"""

# Selecting and counting number of cancelled bookings for each hotel.
cancelled_data = Hotel_df[Hotel_df['is_canceled'] == 1]
cancel_grp = cancelled_data.groupby('hotel')
D1 = pd.DataFrame(cancel_grp.size()).rename(columns = {0:'total_cancelled_bookings'})

# Counting total number of bookings for each type of hotel
grouped_by_hotel = Hotel_df.groupby('hotel')
total_booking = grouped_by_hotel.size()
D2 = pd.DataFrame(total_booking).rename(columns = {0: 'total_bookings'})
D3 = pd.concat([D1,D2], axis = 1)

# Calculating cancel percentage
D3['cancel_%'] = round((D3['total_cancelled_bookings']/D3['total_bookings'])*100,2)
D3

D3.index

pd.DataFrame(cancel_grp.size())

D1.columns

D2

plt.figure(figsize = (10,5))
sns.barplot(x = D3.index, y = D3['cancel_%'])
plt.show()

"""Almost 30 % of City Hotel bookings got canceled.

Q7) Which hotel has high chance that its customer will return for another stay?
"""

# Selecting and counting repeated customers bookings
repeated_data = Hotel_df[Hotel_df['is_repeated_guest'] == 1]
repeat_grp = repeated_data.groupby('hotel')
D1 = pd.DataFrame(repeat_grp.size()).rename(columns = {0:'total_repeated_guests'})

# Counting total bookings
total_booking = grouped_by_hotel.size()
D2 = pd.DataFrame(total_booking).rename(columns = {0: 'total_bookings'})
D3 = pd.concat([D1,D2], axis = 1)

# Calculating repeat %
D3['repeat_%'] = round((D3['total_repeated_guests']/D3['total_bookings'])*100,2)

plt.figure(figsize = (10,5))
sns.barplot(x = D3.index, y = D3['repeat_%'])
plt.show()

"""Both hotels have very small percentage that customer will repeat, but Resort hotel has slightly higher repeat % than City Hotel.

##(2) Distribution Channel wise Analysis

Q1) Which is the most common channel for booking hotels?
"""

group_by_dc = Hotel_df.groupby('distribution_channel')
d1 = pd.DataFrame(round((group_by_dc.size()/Hotel_df.shape[0])*100,2)).reset_index().rename(columns = {0: 'Booking_%'})
plt.figure(figsize = (8,8))
data = d1['Booking_%']
labels = d1['distribution_channel']
plt.pie(x=data, autopct="%.2f%%", explode=[0.05]*5, labels=labels, pctdistance=0.5)
plt.title("Booking % by distribution channels", fontsize=14);

"""Q2) Which channel is mostly used for early booking of hotels?"""

group_by_dc = Hotel_df.groupby('distribution_channel')
d2 = pd.DataFrame(round(group_by_dc['lead_time'].median(),2)).reset_index().rename(columns = {'lead_time': 'median_lead_time'})
plt.figure(figsize = (7,5))
sns.barplot(x = d2['distribution_channel'], y = d2['median_lead_time'])
plt.show()

"""TA/TO is mostly used for planning Hotel visits ahead of time. But for sudden visits other mediums are most preferred.

Q3) Which channel has longer average waiting time?
"""

d4 = pd.DataFrame(round((group_by_dc['days_in_waiting_list']).mean(),2)).reset_index().rename(columns = {'days_in_waiting_list': 'avg_waiting_time'})
plt.figure(figsize = (7,5))
sns.barplot(x = d4['distribution_channel'], y = d4['avg_waiting_time'])
plt.show()

"""While booking via TA/TO one may have to wait a little longer to confirm booking of rooms.

Q4) Which distribution channel brings better revenue generating deals for hotels?
"""

group_by_dc_hotel = Hotel_df.groupby(['distribution_channel', 'hotel'])
d5 = pd.DataFrame(round((group_by_dc_hotel['adr']).agg(np.mean),2)).reset_index().rename(columns = {'adr': 'avg_adr'})
plt.figure(figsize = (7,5))
sns.barplot(x = d5['distribution_channel'], y = d5['avg_adr'], hue = d5['hotel'])
plt.ylim(40,140)
plt.show()

"""GDS channel brings higher revenue generating deals for City hotel, in contrast to that most bookings come via TA/TO. City Hotel can work to increase outreach on GDS channels to get more higher revenue generating deals.

Resort hotel has more revnue generating deals by direct and TA/TO channel. Resort Hotel need to increase outreach on GDS channel to increase revenue.

##(3) Booking cancellation Analysis

Let us try to understand what causes the people to cancel the booking.

Q1) Which significant distribution channel has highest cancellation percentage?
"""

d1 = pd.DataFrame((group_by_dc['is_canceled'].sum()/group_by_dc.size())*100).drop(index = 'Undefined').rename(columns = {0: 'Cancel_%'})
plt.figure(figsize = (10,5))
sns.barplot(x = d1.index, y = d1['Cancel_%'])
plt.show()

"""TA/TO has highest booking cancellation %. Therefore, a booking via TA/TO is 30% likely to get cancelled.

Let us see what causes the cancelation of bookings of rooms by customers

One question can arise that may be longer waiting period or longer lead time causes the cancellation of bookings, let us check that.
"""

waiting_bookings = Hotel_df[Hotel_df['days_in_waiting_list'] !=0]  # Selecting bookings with non zero waiting time


fig, axes = plt.subplots(1, 2, figsize=(18, 8))
sns.kdeplot(ax=axes[0],x = 'days_in_waiting_list', hue = 'is_canceled' , data = waiting_bookings)
sns.kdeplot(ax = axes[1], x = Hotel_df['lead_time'], hue = Hotel_df['is_canceled'])
plt.show()

"""We see that most of the bookings that are cancelled have waiting period of less 150 days but also most of bookings that are not cancelled also have waiting period less than 150 days. Hence this shows that waiting period has no effect on cancellation of bookings.

Also, lead time has no affect on cancellation of bookings, as both curves of cancelation and not cncelation are similar for lead time too.

Now we will check whether not getting allotted the same room type as demanded is the cause of cancellation fo bookings
"""

def check_room_allot(x):
  if x['reserved_room_type'] != x['assigned_room_type']:
    return 1
  else:
    return 0

Hotel_df['same_room_not_alloted'] = Hotel_df.apply(lambda x : check_room_allot(x), axis = 1)
grp_by_canc = Hotel_df.groupby('is_canceled')

D3 = pd.DataFrame((grp_by_canc['same_room_not_alloted'].sum()/grp_by_canc.size())*100).rename(columns = {0: 'same_room_not_alloted_%'})
plt.figure(figsize = (10,7))
sns.barplot(x = D3.index, y = D3['same_room_not_alloted_%'])
plt.show()

"""We see that not getting same room as demanded is not the case of cancellation of rooms. A significant percentage of bookings are not cancelled even after getting different room as demanded.

Lets see does not getting same room affects the adr.
"""

plt.figure(figsize = (12,6))
sns.boxplot(x = 'same_room_not_alloted', y = 'adr', data = Hotel_df)
plt.show()

"""Which are the most busy months?"""

d_month = Hotel_df['arrival_date_month'].value_counts().reset_index()
d_month.columns=['months','Number of guests']
d_month
months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
d_month['months'] = pd.Categorical(d_month['months'], categories=months, ordered=True)
d_month.sort_values('months').reset_index()

data_resort = Hotel_df[(Hotel_df['hotel'] == 'Resort Hotel') & (Hotel_df['is_canceled'] == 0)]
data_city = Hotel_df[(Hotel_df['hotel'] == 'City Hotel') & (Hotel_df['is_canceled'] == 0)]

resort_guest = data_resort['arrival_date_month'].value_counts().reset_index()
resort_guest.columns=['month','no of guests in resort']
resort_guest

city_guest = data_city['arrival_date_month'].value_counts().reset_index()
city_guest.columns=['month','no of guest in city hotel']
city_guest

final_guest=resort_guest.merge(city_guest, on = 'month')
final_guest

months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
final_guest['month'] = pd.Categorical(final_guest['month'], categories=months, ordered=True)
final_guest = final_guest.sort_values('month').reset_index().drop('index',axis=1)

#Which month get most visitors?
sns.lineplot(data=final_guest, x='month', y='no of guests in resort')
sns.lineplot(data=final_guest, x='month', y='no of guest in city hotel')
plt.legend(['Resort','City Hotel'])
plt.ylabel('Number of guest')
fig = plt.gcf()
fig.set_size_inches(15,10)
plt.grid()

"""So not getting same room do affects the adr, people who didn't got same room have paid a little lower adr, except for few exceptions.

Most number of guest comes in month of August.

Now lets see which month results in high revenue.
"""

data_resort1 = Hotel_df[(Hotel_df['hotel'] == 'Resort Hotel') & (Hotel_df['is_canceled'] == 0)]
data_city1 = Hotel_df[(Hotel_df['hotel'] == 'City Hotel') & (Hotel_df['is_canceled'] == 0)]

resort_hotel1 = data_resort.groupby(['arrival_date_month'])['adr'].mean().reset_index()
city_hotel1=data_city.groupby(['arrival_date_month'])['adr'].mean().reset_index()
final_hotel1 = resort_hotel1.merge(city_hotel1, on = 'arrival_date_month')
final_hotel1.columns = ['month', 'price_for_resort', 'price_for_city_hotel']

months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
final_hotel1['month'] = pd.Categorical(final_hotel1['month'], categories=months, ordered=True)
final_hotel = final_hotel1.sort_values('month').reset_index().drop('index',axis=1)

sns.lineplot(data=final_hotel, x='month', y='price_for_resort')
sns.lineplot(data=final_hotel1, x='month', y='price_for_city_hotel')
plt.legend(['Resort','City Hotel'])
plt.ylabel('adr')
fig = plt.gcf()
fig.set_size_inches(15,10)
plt.grid()

reindex = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']

Hotel_df['arrival_date_month'] = pd.Categorical(Hotel_df['arrival_date_month'], categories=reindex, ordered=True)

grouped_data = [Hotel_df.loc[Hotel_df['arrival_date_month'] == month, 'adr'] for month in reindex]

colors = ['orange', 'blue', 'green', 'red', 'purple', 'yellow', 'pink', 'brown', 'gray', 'cyan', 'magenta', 'lime']

fig, ax = plt.subplots(figsize=(15, 8))

# Plot the boxplots with individual colors
boxplot = ax.boxplot(grouped_data, labels=reindex, patch_artist=True)

# Set the facecolor of each box
for box, color in zip(boxplot['boxes'], colors):
    box.set(facecolor=color)

ax.set_xlabel('Months')
ax.set_ylabel('ADR')

plt.show()

"""Avg adr rises from beginning of year upto middle of year and reaches peak at August and then lowers to the end of year. But hotels do make some good deals with high adr at end of year also.

Now let us check the trend of arrival_num and avg adr within a month.
"""

trend_data =pd.DataFrame(not_canceled.groupby('arrival_date_day_of_month')['adr'].count()).rename(columns={'adr':'Arrival_num'})
trend_data['avg_adr'] = not_canceled.groupby('arrival_date_day_of_month')['adr'].mean()

trend_data=trend_data.reset_index()

trend_data =pd.DataFrame(not_canceled.groupby('arrival_date_day_of_month')['adr'].count()).rename(columns={'adr':'Arrival_num'})
trend_data['avg_adr'] = not_canceled.groupby('arrival_date_day_of_month')['adr'].mean()
trend_data=trend_data.reset_index()

fig, axes = plt.subplots(1, 2, figsize=(18, 8))

# Plotting arrival num for each day of month
l = trend_data.plot(ax=axes[0], x='arrival_date_day_of_month', y='Arrival_num')
axes[0].set_title('Trend of arrival throughout the month',fontweight="bold")
axes[0].set_ylabel('Arrival_num')
axes[0].set_xlabel('arrival_date_day_of_month')
l.grid()
l.set_xticks([1, 7, 14, 21, 28, 31])
l.set_xticklabels([1, 7, 14, 21, 28, 31])

# # Plotting avg adr for each day of month
m = trend_data.plot(ax=axes[1], x='arrival_date_day_of_month', y='avg_adr')
axes[1].set_title('Trend of avg_adr throughout the month',fontweight="bold")
axes[1].set_ylabel('avg_adr')
axes[1].set_xlabel('arrival_date_day_of_month')
m.grid()
m.set_xticks([1, 7, 14, 21, 28, 31])
m.set_xticklabels([1, 7, 14, 21, 28, 31])

#plt.tight_layout()  # Adjust spacing between subplots
plt.show()

"""We can see that graph Arrival_num has small peaks at regular interval of days. This can be due to increase in arrival weekend.

Also the avg adr tends to go up as month ends. Therefore charge more at the end of month.

Let us divide our customers in three categories of single, couple and family/friends. then check their booking %
"""

# Filter the data for each category
single = not_canceled[(not_canceled['adults'] == 1) & (not_canceled['children'] == 0) & (not_canceled['babies'] == 0)]
couple = not_canceled[(not_canceled['adults'] == 2) & (not_canceled['children'] == 0) & (not_canceled['babies'] == 0)]
family = not_canceled[not_canceled['adults'] + not_canceled['children'] + not_canceled['babies'] > 2]

# Define the order of months
reindex = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']

# Group the data by month and count the occurrences for each category
grouped_data = pd.DataFrame()
grouped_data['single'] = single.groupby('arrival_date_month').size()
grouped_data['couple'] = couple.groupby('arrival_date_month').size()
grouped_data['family'] = family.groupby('arrival_date_month').size()

# Reorder the rows of the DataFrame using the defined order of months
grouped_data = grouped_data.reindex(reindex)

# Create the plot
fig, ax = plt.subplots(figsize=(12, 8))
sns.lineplot(data=grouped_data, markers=True, ax=ax)

# Set the x-axis labels to the month names
ax.set_xticklabels(reindex)

# Add grid lines
plt.grid()

# Show the plot
plt.show()

"""Moslty bookings are done by couples(although we are not sure that they are couple as data doesn't tell about that)

It is clear from graph that their is a sudden surge in arrival num of couples and family in months of July and August. So better plans can be planned accordingly at that time for these type of customers.

##What if you wanted to predict whether or not a hotel was likely to receive a disproportionately high number of special requests?
"""

plt.figure(figsize=(15, 10))

# Extract the data for plotting
x_data = Hotel_df["market_segment"]
y_data = Hotel_df["total_of_special_requests"]

# Use boxplot to plot the data
boxplot = plt.boxplot([y_data[x_data == segment] for segment in x_data.unique()], labels=x_data.unique(), patch_artist=True)

# Set the color of the boxes
colors = ['orange', 'blue', 'green', 'red', 'purple', 'yellow', 'pink', 'brown', 'gray', 'cyan', 'magenta', 'lime']
for box, color in zip(boxplot['boxes'], colors):
    box.set(facecolor=color)

# Add a legend
plt.legend(boxplot['boxes'], x_data.unique())

# Set labels and title
plt.xlabel('Market Segment')
plt.ylabel('Total Special Requests')
plt.title('Special Requests by Market Segment')

plt.show()

"""All of market segment mostly have special request."""

#Special request accoring to number of kid.
Hotel_df['kids'] = Hotel_df['children']+Hotel_df['babies']
sns.barplot(x="kids", y="total_of_special_requests",data= Hotel_df)
fig = plt.gcf()
fig.set_size_inches(15,10)

#Special request accoring to number of kid.
sns.barplot(x="adults", y="total_of_special_requests",data= Hotel_df)
fig = plt.gcf()
fig.set_size_inches(15,10)

"""##From where the most guests are coming ?"""

country_wise_guests = Hotel_df[Hotel_df['is_canceled'] == 0]['country'].value_counts().reset_index()
country_wise_guests.columns = ['country', 'No of guests']
country_wise_guests

grouped_by_country =Hotel_df.groupby('country')
d1 = pd.DataFrame(grouped_by_country.size()).reset_index().rename(columns = {0:'Count'}).sort_values('Count', ascending = False)[:10]
sns.barplot(x = d1['country'], y  = d1['Count'])
plt.show()

"""Most guest are from Portugal and other Europian contries."""